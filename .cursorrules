# Cursor Rules

## Code Style Guidelines

### DO NOT create import-and-reexport patterns

**NEVER** create patterns like this:
```typescript
// In file A.ts
export { functionFromB } from "./B";
```

**Why:** This creates unnecessary indirection and makes it harder to find where functions are actually defined. It also creates circular dependency risks and makes refactoring more difficult.

**Instead:** 
- Export functions directly from their source files
- If you need to expose them from a package's main index, add them there directly:
  ```typescript
  // In packages/api/src/index.ts
  export { functionFromB } from "./lib/B";
  ```

**Exception:** Only use re-exports when creating a public API from a package's main index file (like `packages/api/src/index.ts`), and only export from subdirectories/modules, not from peer files at the same level.

**CRITICAL:** NEVER add re-exports (including type re-exports) in internal library files. Re-exports should ONLY be in the package's main index file (e.g., `packages/task-queue/src/index.ts`). Internal files should import directly from their dependencies, not re-export them.

### Code Formatting: else statements

**NEVER** put `else` or `else if` on the same line as a closing bracket.

**Bad:**
```typescript
if (condition) {
    // code
} else {
    // code
}
```

**Good:**
```typescript
if (condition) {
    // code
}
else {
    // code
}
```

### Code Formatting: catch blocks

**NEVER** put `catch` on the same line as a closing bracket.

**Bad:**
```typescript
try {
    // code
} catch (error) {
    // code
}
```

**Good:**
```typescript
try {
    // code
}
catch (error) {
    // code
}
```

### File Naming: Use kebab-case

**ALWAYS** use kebab-case (lowercase with hyphens) for file names, not camelCase or snake_case.

**Why:** Consistent naming convention improves code readability and follows common web development practices.

**Examples:**
- ✅ `use-web-socket.ts`
- ✅ `user-profile.tsx`
- ✅ `api-client.ts`
- ❌ `useWebSocket.ts` (camelCase)
- ❌ `use_web_socket.ts` (snake_case)

### TypeScript: Avoid `any` type

**NEVER** use the `any` type unless absolutely necessary. When `any` is required, it must be accompanied by a comment explaining why it's necessary and what the actual type should be.

**Why:** Using `any` defeats the purpose of TypeScript's type safety and can lead to runtime errors that could have been caught at compile time.

**Instead:**
- Use proper TypeScript types
- Use `unknown` for error handling when the error type is uncertain
- Use union types with `undefined` for optional values (e.g., `string | undefined`)
- Use generic types when appropriate
- If you must use `any`, add a comment explaining why and what the actual type should be

**Bad:**
```typescript
let data: any = getData();
function process(item: any) { ... }
```

**Good:**
```typescript
let data: MyDataType | undefined = getData();
function process(item: IProcessableItem) { ... }
catch (err: unknown) {
    const error = err instanceof Error ? err : new Error(String(err));
    // handle error
}
```

### TypeScript: Never use dynamic imports

**NEVER** use dynamic imports (like `import("package")`) in type definitions or anywhere else. Always use static imports at the top of the file.

**Why:** Dynamic imports create unnecessary complexity, can cause bundling issues, and make it harder to track dependencies. Static imports are clearer and more predictable.

**Bad:**
```typescript
export interface IProps {
    provider?: import("api").ITaskQueueProvider;
}
```

**Good:**
```typescript
import type { ITaskQueueProvider } from "api";

export interface IProps {
    provider?: ITaskQueueProvider;
}
```

### JavaScript/TypeScript: Never use lazy requires or imports

**NEVER** use lazy requires or imports (loading modules inside functions, conditionally, or on-demand). Always require/import at the top of the file.

**Why:** Lazy loading makes code harder to understand, can cause module instance mismatches, makes dependency tracking difficult, and can lead to subtle bugs where different parts of the code access different module instances.

**Bad:**
```javascript
function getHandler(type) {
    if (!getHandlerFunction) {
        const taskQueue = require('task-queue');
        getHandlerFunction = taskQueue.getHandler;
    }
    return getHandlerFunction(type);
}
```

**Good:**
```javascript
const { getHandler } = require('task-queue');

function getHandler(type) {
    return getHandler(type);
}
```

## Critical Workflow Rules

### NEVER finish up until all code is compiling

**ALWAYS** run `bun run c` on the entire project before considering work complete. Do not assume the code compiles just because the linter shows no errors. TypeScript compilation may catch errors that the linter doesn't.

**IMPORTANT:** Only run `bun run c` when you are completely finished with a task, not after each individual change. This reduces unnecessary compilation runs and speeds up development.

**Before marking any task as complete:**
1. Run `bun run c` to compile the entire project
2. Fix any compilation errors
3. Only then consider the work done
