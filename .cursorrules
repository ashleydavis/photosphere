# Cursor Rules

## Code Style Guidelines

### DO NOT create import-and-reexport patterns

**NEVER** create patterns like this:
```typescript
// In file A.ts
export { functionFromB } from "./B";
```

**Why:** This creates unnecessary indirection and makes it harder to find where functions are actually defined. It also creates circular dependency risks and makes refactoring more difficult.

**Instead:** 
- Export functions directly from their source files
- If you need to expose them from a package's main index, add them there directly:
  ```typescript
  // In packages/api/src/index.ts
  export { functionFromB } from "./lib/B";
  ```

**Exception:** Only use re-exports when creating a public API from a package's main index file (like `packages/api/src/index.ts`), and only export from subdirectories/modules, not from peer files at the same level.

**CRITICAL:** NEVER add re-exports (including type re-exports) in internal library files. Re-exports should ONLY be in the package's main index file (e.g., `packages/task-queue/src/index.ts`). Internal files should import directly from their dependencies, not re-export them.

### Code Formatting: else statements

**NEVER** put `else` or `else if` on the same line as a closing bracket.

**Bad:**
```typescript
if (condition) {
    // code
} else {
    // code
}
```

**Good:**
```typescript
if (condition) {
    // code
}
else {
    // code
}
```

### Code Formatting: catch blocks

**NEVER** put `catch` on the same line as a closing bracket.

**Bad:**
```typescript
try {
    // code
} catch (error) {
    // code
}
```

**Good:**
```typescript
try {
    // code
}
catch (error) {
    // code
}
```

### File Naming: Use kebab-case

**ALWAYS** use kebab-case (lowercase with hyphens) for file names, not camelCase or snake_case.

**Why:** Consistent naming convention improves code readability and follows common web development practices.

**Examples:**
- ✅ `use-web-socket.ts`
- ✅ `user-profile.tsx`
- ✅ `api-client.ts`
- ❌ `useWebSocket.ts` (camelCase)
- ❌ `use_web_socket.ts` (snake_case)

### TypeScript: Avoid `any` type

**NEVER** use the `any` type unless the user specifically asks you to do so. This is a critical rule that must be followed strictly.

**Why:** Using `any` defeats the purpose of TypeScript's type safety and can lead to runtime errors that could have been caught at compile time. Always use proper types, `unknown`, or create interfaces/types as needed.

**Exceptions:**
- `any` is acceptable in catch handlers: `catch (error: any) { ... }`
- `any` is acceptable for task data fields that can be any type: `data: any`

**Instead:**
- Use proper TypeScript types
- Use `unknown` for error handling when the error type is uncertain (unless in a catch handler)
- Use union types with `undefined` for optional values (e.g., `string | undefined`)
- Use generic types when appropriate
- If you must use `any`, add a comment explaining why and what the actual type should be

**Bad:**
```typescript
let data: any = getData();
function process(item: any) { ... }
```

**Good:**
```typescript
let data: MyDataType | undefined = getData();
function process(item: IProcessableItem) { ... }
catch (error: any) {
    // any is acceptable in catch handlers
    console.error(error.message || error);
}
```

### TypeScript: Never use dynamic imports

**NEVER** use dynamic imports (like `import("package")`) in type definitions or anywhere else. Always use static imports at the top of the file.

**Why:** Dynamic imports create unnecessary complexity, can cause bundling issues, and make it harder to track dependencies. Static imports are clearer and more predictable.

**Bad:**
```typescript
export interface IProps {
    provider?: import("api").ITaskQueueProvider;
}
```

**Good:**
```typescript
import type { ITaskQueueProvider } from "api";

export interface IProps {
    provider?: ITaskQueueProvider;
}
```

### JavaScript/TypeScript: Never use lazy requires or imports

**NEVER** use lazy requires or imports (loading modules inside functions, conditionally, or on-demand). Always require/import at the top of the file.

**Why:** Lazy loading makes code harder to understand, can cause module instance mismatches, makes dependency tracking difficult, and can lead to subtle bugs where different parts of the code access different module instances.

**Bad:**
```javascript
function getHandler(type) {
    if (!getHandlerFunction) {
        const taskQueue = require('task-queue');
        getHandlerFunction = taskQueue.getHandler;
    }
    return getHandlerFunction(type);
}
```

**Good:**
```javascript
const { getHandler } = require('task-queue');

function getHandler(type) {
    return getHandler(type);
}
```

## Critical Workflow Rules

### This is a Bun project - use Bun commands, not Node.js/npm

**ALWAYS** use Bun commands instead of Node.js or npm commands unless the user explicitly requests otherwise.

**Why:** This project uses Bun as its runtime and package manager. Using npm or Node.js commands can cause inconsistencies, slower performance, and may not work correctly with Bun's module resolution and features.

**Examples:**
- ✅ `bun run test` (not `npm test`)
- ✅ `bun run compile` (not `npm run compile`)
- ✅ `bun install` (not `npm install`)
- ✅ `bun test` (not `node test.js` or `jest`)
- ✅ `bun run c` (not `npm run c`)

**When to use Node.js/npm:**
- Only when the user explicitly requests it
- When working with tools that specifically require Node.js (e.g., certain build tools that don't support Bun)

### NEVER finish up until all code is compiling

**ALWAYS** run `bun run c` on the entire project before considering work complete. Do not assume the code compiles just because the linter shows no errors. TypeScript compilation may catch errors that the linter doesn't.

**IMPORTANT:** Only run `bun run c` when you are completely finished with a task, not after each individual change. This reduces unnecessary compilation runs and speeds up development.

**Before marking any task as complete:**
1. Run `bun run c` to compile the entire project
2. Fix any compilation errors
3. Only then consider the work done
